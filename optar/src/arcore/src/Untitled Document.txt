#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <geometry_msgs/PointStamped.h>
#include <geometry_msgs/PoseArray.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/Point.h>
#include <geometry_msgs/Vector3.h>
#include "std_msgs/String.h"


/*
// publish the message as Tf arrived from ARcore

 void chatterCallback(const geometry_msgs::PoseStamped::ConstPtr& msg)
  {
	ROS_INFO("Received pose: x: %f , y: %f, z: %f" , msg->pose.position.x, msg->pose.position.y, msg->pose.position.z);
   
static tf::TransformBroadcaster br;

  tf::Transform transform;
  transform.setOrigin( tf::Vector3(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z) );
  tf::Quaternion q(msg->pose.orientation.x, msg->pose.orientation.y, msg->pose.orientation.z, msg->pose.orientation.w);

  transform.setRotation(q);
  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "map", "arcore"));
  }
*/

static geometry_msgs::PoseStamped apriltag;
static geometry_msgs::PoseStamped apriltagMobile;
static tf::Quaternion offsetAngle;


void listenerApriltag(const geometry_msgs::PoseArray::ConstPtr& msg)
  {
	//ROS_INFO("Received apriltag position: x: %f" , msg->poses[0].position.x);
  apriltag.pose.position = msg->poses[0].position;
  apriltag.pose.orientation = msg->poses[0].orientation;
  }

  void listenerApriltagMobile(const geometry_msgs::PoseStamped::ConstPtr& msg)
  {
	//ROS_INFO("Received apriltag position: x: %f" , msg->poses[0].position.x);
  apriltagMobile.pose.position =  msg->pose.position;
  apriltagMobile.pose.orientation =  msg->pose.orientation;

  tf::Quaternion quaternionMobile(apriltagMobile.pose.orientation.x, apriltagMobile.pose.orientation.y, apriltagMobile.pose.orientation.z, apriltagMobile.pose.orientation.w);
  tf::Matrix3x3 mobileTag(quaternionMobile);
  double mobile_roll, mobile_pitch, mobile_yaw;
  mobileTag.getRPY(mobile_roll, mobile_pitch, mobile_yaw);

  tf::Quaternion quaternionReal(apriltag.pose.orientation.x, apriltag.pose.orientation.y, apriltag.pose.orientation.z, apriltag.pose.orientation.w);
  tf::Matrix3x3 realTag(quaternionReal);
  double real_roll, real_pitch, real_yaw;
  realTag.getRPY(real_roll, real_pitch, real_yaw);
  
  double roll, pitch, yaw;
  roll = real_roll - mobile_roll;
  pitch = real_pitch - mobile_pitch;
  yaw = real_yaw - mobile_yaw;

  offsetAngle.setRPY(roll, pitch, yaw);
  }


 void chatterCallback(const geometry_msgs::PoseStamped::ConstPtr& msg)
  {
	//ROS_INFO("Received ratio: x: %f , y: %f, z: %f" , msg->pose.position.x, msg->pose.position.y, msg->pose.position.z);
  ROS_INFO("Received april: x: %f , y: %f, z: %f, w: %f" , msg->pose.orientation.x, msg->pose.orientation.y, msg->pose.orientation.z, msg->pose.orientation.w);
   
  tf::Quaternion quaternionCamera(msg->pose.orientation.x, msg->pose.orientation.y, msg->pose.orientation.z, msg->pose.orientation.w);
  tf::Matrix3x3 cameraMobile(quaternionCamera);
  double camera_roll, camera_pitch, camera_yaw;
  cameraMobile.getRPY(camera_roll, camera_pitch, camera_yaw);

  tf::Matrix3x3 finalAngle(offsetAngle);
  double final_roll, final_pitch, final_yaw;
  finalAngle.getRPY(final_roll, final_pitch, final_yaw);

  final_roll += camera_roll;
  final_pitch += camera_pitch;
  final_yaw += camera_yaw;

  tf::Quaternion finalQuaternion;
  finalQuaternion.setRPY(final_roll, final_pitch, final_yaw);

  static tf::TransformBroadcaster br;
  tf::Transform transform;

  transform.setOrigin( tf::Vector3(msg->pose.position.x, msg->pose.position.y, msg->pose.position.z) );
  //transform.setRotation( tf::Quaternion(msg->pose.orientation.x, msg->pose.orientation.y, msg->pose.orientation.z, msg->pose.orientation.w));
  transform.setRotation( finalQuaternion );

  
  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "tag_0", "estimated"));


  }

/*
void poseCallback(const geometry_msgs::PoseStamped& msg){
  static tf::TransformBroadcaster br;
ROS_INFO("123","ho sentito %f %f %f", msg.pose.position.x, msg.pose.position.y, msg.pose.position.z);

  tf::Transform transform;
  transform.setOrigin( tf::Vector3(1,1,1) );
  tf::Quaternion q;
  q.setRPY(0, 0, 0);
  transform.setRotation(q);
  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "world", "arcore"));

}

int main(int argc, char** argv){
  ros::init(argc, argv, "my_tf_broadcaster");

  ros::NodeHandle node;
  ros::Subscriber sub = node.subscribe("/vodom", 1000, &poseCallback);

  static tf::TransformBroadcaster br;
  tf::Transform transform;
  transform.setOrigin( tf::Vector3(1,1,1) );
  tf::Quaternion q;
  q.setRPY(0, 0, 0);
  transform.setRotation(q);
  br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "world", "arcore"));

  ros::spin();
  return 0;
}
*/


int main(int argc, char **argv)
{
  
  ros::init(argc, argv, "listener");

  ros::NodeHandle n;
  ros::NodeHandle n1;
  ros::NodeHandle n2;

  ros::Subscriber sub = n.subscribe("/camera_network/tag_detections_pose", 1000, listenerApriltag);
  ros::Subscriber sub1 = n1.subscribe("/mobile_apriltag", 1000, listenerApriltagMobile);
  ros::Subscriber sub2 = n2.subscribe("vodom", 1000, chatterCallback);

  ros::spin();

  return 0;
}








void updatePositionTag(std_msgs::Header header)
{
  tf::StampedTransform transform;
  tf::TransformListener listener;

  try{
    listener.lookupTransform("arcore", "/kinect2_head_rgb_optical_frame", ros::Time(0), transform);  
  }
  catch(tf::TransformException &ex){
    ROS_ERROR("ARCORE -> %s", ex.what());
  }
  
  publishMarker(header, transform.getOrigin(), transform.getRotation());

}